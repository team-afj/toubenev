from __future__ import annotations  # allows class type usage in class decl
from typing import List, Dict
from datetime import date, time, datetime, timedelta
from operator import contains
from ortools.sat.python import cp_model
from data_model import BÃ©nÃ©vole, Lieu, Type_de_quÃªte, QuÃªte

# import import_csv
from import_json import from_file

from_file("data/db.json")

quÃªtes = sorted(QuÃªte.toutes)
bÃ©nÃ©voles = BÃ©nÃ©vole.tous.values()


def quÃªtes_dun_lieu(lieu):
    return filter(lambda q: q.lieu == lieu, quÃªtes)


id_quÃªte_sÃ©rÃ©nitÃ© = "784fc134-cab5-4797-8be2-7a7a91e57795"

"""PrÃ©paration du modÃ¨le et des contraintes"""

model = cp_model.CpModel()

""" On crÃ©Ã© une variable par bÃ©nÃ©vole pour chaque "slot" de chaque quÃªte."""
assignations: Dict[(BÃ©nÃ©vole, QuÃªte, int), cp_model.BoolVarT] = {}
for b in bÃ©nÃ©voles:
    for q in quÃªtes:
        assignations[(b, q)] = model.new_bool_var(f"shift_b{b}_q{q}")

""" Tous les slots de toutes les quÃªtes doivent Ãªtre peuplÃ©s """
for q in quÃªtes:
    model.add(sum(assignations[(b, q)] for b in bÃ©nÃ©voles) == q.nombre_bÃ©nÃ©voles)

""" Un mÃªme bÃ©nÃ©vole ne peut pas remplir plusieurs quÃªtes en mÃªme temps """
for b in bÃ©nÃ©voles:
    for q in quÃªtes:
        model.add_at_most_one(
            assignations[(b, q_en_mÃªme_temps)] for q_en_mÃªme_temps in q.en_mÃªme_temps()
        )

""" Certaines quÃªtes sont dÃ©jÃ  assignÃ©es """
for q in quÃªtes:
    for b in q.bÃ©nÃ©voles:
        model.add(assignations[(b, q)] == 1)


""" Certains bÃ©nÃ©voles sont indisponibles Ã  certains horaires """
for b in bÃ©nÃ©voles:
    for q in quÃªtes:
        # On vÃ©rifie que ce n'est pas une quÃªte forcÃ©e:
        if not (contains(q.bÃ©nÃ©voles, b)):
            for dÃ©but_indispo in b.indisponibilitÃ©s:
                fin_indispo = time((dÃ©but_indispo.hour + 1) % 24)
                if not (fin_indispo <= q.dÃ©but.time() or dÃ©but_indispo >= q.fin.time()):
                    model.add(assignations[(b, q)] == 0)

""" Tout le monde ne peut pas assumer les quÃªtes sÃ©rÃ©nitÃ© """
for b in bÃ©nÃ©voles:
    if not (b.sÃ©rÃ©nitÃ©):
        for q in quÃªtes:
            if contains(q.types, Type_de_quÃªte.tous[id_quÃªte_sÃ©rÃ©nitÃ©]):
                model.add(assignations[(b, q)] == 0)

""" Les lieux interdits sont interdits """
for b in bÃ©nÃ©voles:
    for lieu in b.lieux_interdits:
        for q in quÃªtes_dun_lieu(lieu):
            model.add(assignations[(b, q)] == 0)


""" Ils se dÃ©testent, sÃ©parez-les ! """
for b in bÃ©nÃ©voles:
    for e in b.binÃ´mes_interdits:
        for q in quÃªtes:
            model.add(assignations[(b, q)] + assignations[(e, q)] <= 1)

""" Chacun a un trou dans son emploi du temps """


def time_to_minutes(t: time):
    return t.hour * 60 + t.minute


def diff_minutes(t1: time, t2: time):
    return time_to_minutes(t2) - time_to_minutes(t1)


def min_pause(b: BÃ©nÃ©vole, durÃ©e_pause):
    # Todo: we use a lot of additionnal variable and calls to max which can be
    # very bed for performances There might be a better way. Maybe trying to fit
    # an large enough interval that doesn't overlaps with any quest ?
    for date, quÃªtes in QuÃªte.par_jour.items():
        quÃªtes = sorted(quÃªtes)
        max_pause = 0
        last_quÃªte_end = 9 * 60  # 9h
        # Todo, we should also count the last quest of the day
        for q in quÃªtes:

            last_quÃªte_end_var = model.new_int_var(
                0, 24 * 60, f"last_quete_end_{b}_{q.nom}"
            )

            # If assigned, update last_quest_end time
            model.add(
                last_quÃªte_end_var == time_to_minutes(q.fin.time())
            ).only_enforce_if(assignations[(b, q)])
            model.add(last_quÃªte_end_var == last_quÃªte_end).only_enforce_if(
                assignations[(b, q)].Not()
            )
            last_quÃªte_end = last_quÃªte_end_var

            max_pause_var = model.new_int_var(0, 24 * 60, f"max_pause_{b}_{q.nom}")

            # Time elapsed since last quest end
            diff = time_to_minutes(q.dÃ©but.time()) - last_quÃªte_end
            model.add_max_equality(max_pause_var, [max_pause, diff])
            max_pause = max_pause_var

        model.add(max_pause >= durÃ©e_pause)


durÃ©e_pause = 5 * 60  # 5h en minutes
for b in bÃ©nÃ©voles:
    min_pause(b, durÃ©e_pause)


""" Calcul de la qualitÃ© d'une rÃ©ponse """

""" ContrÃ´le du temps de travail """


# Temps de travail d'un bÃ©nÃ©vole sur un ensemble de quÃªtes
def temps_bev(b, quÃªtes):
    return sum(q.durÃ©e_minutes() * assignations[(b, q)] for q in quÃªtes)


# Temps de travail, par jour, d'un bÃ©nÃ©vole
def temps_total_bÃ©nÃ©vole(b) -> Dict[date, cp_model.IntVar]:
    return {date: temps_bev(b, quÃªtes) for date, quÃªtes in QuÃªte.par_jour.items()}


# DiffÃ©rence avec le tdt prÃ©vu par jour:
def diff_temps(b):
    return {
        date: tdt - (b.heures_thÃ©oriques * 60)
        for date, tdt in temps_total_bÃ©nÃ©vole(b).items()
    }


def squared(id, value):
    var = model.NewIntVar(0, 100000, f"v_squared_{id}")
    diff = model.NewIntVar(-100000, 100000, f"v_{id}")
    model.Add(diff == value)
    model.AddMultiplicationEquality(var, [diff, diff])
    # model.AddAbsEquality(var, diff)
    return var


# Au carrÃ©:
diffs: Dict[BÃ©nÃ©vole, cp_model.IntVar] = {}
for b in bÃ©nÃ©voles:
    diff_par_jour = diff_temps(b)
    diffs[b] = sum(
        squared(f"diff_{date}_bÃ©nÃ©_{b}", diff) for date, diff in diff_par_jour.items()
    )

# max_diff = model.NewIntVar(0, 100000, f"max_diff")
# model.AddMaxEquality(max_diff, diffs.values())
# Ã©cart type ?

""" PondÃ©ration des prÃ©fÃ©rences des bÃ©nÃ©voles """


def apprÃ©ciation_dune_quÃªte(bÃ©nÃ©vole: BÃ©nÃ©vole, quÃªte: QuÃªte):
    # On dÃ©coupe la quÃªte par blocs de 15 minutes
    acc = quÃªte.dÃ©but
    somme_prefs = 0
    while acc < quÃªte.fin:
        time = acc.time()
        for pref_t, p in bÃ©nÃ©vole.pref_horaires.items():
            if time.hour == pref_t.hour:
                somme_prefs += p * 2
                break
        acc = min(acc + timedelta(minutes=15), quÃªte.fin)
    return somme_prefs


def apprÃ©ciation_du_planning(bÃ©nÃ©vole: BÃ©nÃ©vole, quÃªtes: List[QuÃªte]):
    return sum(
        assignations[(bÃ©nÃ©vole, q)] * (apprÃ©ciation_dune_quÃªte(bÃ©nÃ©vole, q))
        for q in quÃªtes
    )


""" Formule finale """

model.minimize(sum(diffs[b] - apprÃ©ciation_du_planning(b, quÃªtes) for b in bÃ©nÃ©voles))


""" Solution printer """


def smile_of_apprÃ©ciation(app):
    smile = "ğŸ™‚"
    if app >= 2:
        smile = "ğŸ˜ƒ"
    if app < 0:
        smile = "ğŸ˜¥"
    if app < -5:
        smile = "ğŸ˜­"
    return smile


class VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""

    def __init__(self, assignations):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self._assignations = assignations
        self._solution_count = 0

    def on_solution_callback(self) -> None:
        self._solution_count += 1
        print(f"Solution {self._solution_count}")
        for q in quÃªtes:
            result = ""
            for b in bÃ©nÃ©voles:
                if self.value(self._assignations[(b, q)]) == 1:
                    app = apprÃ©ciation_dune_quÃªte(b, q)
                    smile = smile_of_apprÃ©ciation(app)
                    if result == "":
                        result = f"{b} {smile}"
                    else:
                        result = f"{result}, {b} {smile}"
            print(f"QuÃªte {q}: {result}")
        print()

    @property
    def solution_count(self) -> int:
        return self.__solution_count


# Enumerate all solutions.
solver = cp_model.CpSolver()
solution_printer = VarArraySolutionPrinter(assignations)
solver.parameters.log_search_progress = False
solver.parameters.num_workers = 16

status = solver.solve(model, solution_printer)


# Best solution:
if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    if status == cp_model.OPTIMAL:
        print("Optimal solution:")
    else:
        print("Non-optimal solution:")
    for q in quÃªtes:
        result = ""
        for b in bÃ©nÃ©voles:
            if solver.value(assignations[(b, q)]) == 1:
                app = apprÃ©ciation_dune_quÃªte(b, q)
                if result == "":
                    result = f"{b} ({app})"
                else:
                    result = f"{result}, {b} ({app})"
        print(f"QuÃªte {q}: {result}")
    max_diff = 0
    max_diff_abs = 0
    for b in bÃ©nÃ©voles:
        minutes = solver.value(sum(temps_total_bÃ©nÃ©vole(b).values()))
        diff = solver.value(sum(diff_temps(b).values()))
        if abs(diff) > max_diff_abs:
            max_diff = diff
            max_diff_abs = abs(diff)
        print(
            f"{b.surnom}: {int(minutes // 60):0=2d}h{int(minutes % 60):0=2d} ({diff/60:.1f})"
        )
    print(
        f"Objective value = {solver.objective_value}",
    )
    print(f"Deviation horaire maximale = {max_diff}")
else:
    print("No optimal solution found !")


""" Quelques donnÃ©es sur les quÃªtes """


def total_temps_travail(quÃªtes: List[QuÃªte]):
    return sum(q.durÃ©e_minutes() * q.nombre_bÃ©nÃ©voles for q in quÃªtes)


def total_temps_dispo(bÃ©nÃ©voles: List[BÃ©nÃ©vole]):
    return sum(b.heures_thÃ©oriques * 60 for b in bÃ©nÃ©voles)


temps_total = total_temps_travail(quÃªtes)
temps_dispo = total_temps_dispo(bÃ©nÃ©voles)
print()
print(
    f"Temps de travail total: {int(temps_total // 60):0=2d}h{int(temps_total % 60):0=2d}"
)
print(
    f"Temps de travail disponible: {int(temps_dispo // 60):0=2d}h{int(temps_dispo % 60):0=2d}"
)

# Statistics.
print("\nStatistics")
print(f"- conflicts: {solver.num_conflicts}")
print(f"- branches : {solver.num_branches}")
print(f"- wall time: {solver.wall_time}s")


result: Dict[QuÃªte, List[BÃ©nÃ©vole]] = {}
for q in quÃªtes:
    participants = []
    for b in bÃ©nÃ©voles:
        if solver.value(assignations[(b, q)]):
            participants.append(b)
    result[q] = participants

from export_json import write_json

write_json(result)

"""
  Autres contraintes:
  - [x] Respect temps horaire quotidien
  - [ ] Une pause de 4-5 heures consÃ©cutive chaque jour
  - [ ] Des activitÃ©s diffÃ©rentes chaque jour ?
  - [ ] Des horaires diffÃ©rents chaque jour ?
  - [x] La sÃ©rÃ©nitÃ©
  - [x] Les horaires indispo
  - [x] Les horaires de prÃ©dilection
  - [ ] Equilibrer les dÃ©ficits ou les excÃ¨s
  - [ ] Pause de 15 minutes entre deux missions qui ne sont pas dans le mÃªme lieu
  - [ ] Sur les scÃ¨nes, on veut que les tÃ¢ches consÃ©cutives soit si possible faites par les mÃªmes personnes
  - [ ] A la fin de la semaine, c'est cool si tout le monde a fait chaque type de quÃªtes
"""

from icalendar import Calendar, Event

cal = Calendar()
cal.add("prodid", "-//LBC Calendar//mxm.dk//")
cal.add("version", "2.0")

for q in quÃªtes:
    result = ""
    for b in bÃ©nÃ©voles:
        if solver.value(assignations[(b, q)]) == 1:
            app = apprÃ©ciation_dune_quÃªte(b, q)
            smile = smile_of_apprÃ©ciation(app)
            if result == "":
                result = f"{b} {smile}"
            else:
                result = f"{result}, {b} {smile}"
    event = Event()
    event.add("summary", f"{result}: {q.nom}")
    lieu = "partout"
    if q.lieu:
        lieu = q.lieu.nom
    event.add("description", f"Lieu: {lieu}")
    event.add("dtstart", q.dÃ©but)
    event.add("dtend", q.fin)
    event.add("dtstamp", q.fin)
    cal.add_component(event)

import os

path = os.path.join(os.getcwd(), "example.ics")
f = open(path, "wb")
f.write(cal.to_ical())
f.close()

print(path)
